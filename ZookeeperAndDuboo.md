# 为什么要有分布式系统？

因为当你的计算机量足够大的时候，就算榨干了机器的计算能力也算不过来，怎么办？此时一台机器已经满足不了实际情况了，所以就得多搞几台机器，多搞几台机器就构成了分布式系统。它最大的优点就是可以解决单机资源舒服问题。

# 什么是分布式系统？

- 很多台计算机组成一个整体，一个整体一致对外并处理同一请求。
- 内部的每台计算机都可以相互通信。主流的通信有：`RPC RESTFUL`
- 客户端到服务器端的一次请求到响应结束会历经多台计算机。

比如这么一个场景就用到了分布式系统：【其实就是把原有的单体系统根据业务拆分成多个系统】

![](https://img-blog.csdnimg.cn/17a933cc361e47df90c05d9b9c04657a.png)

# 分布式系统的瓶颈

- 部署复杂需要同时部署多个服务
- 系统吞吐量虽然变大了，但是可能需要经过好几个模块响应时间会变慢
- 架构设计变得非常复杂，所以出现问题时排查和测试就变得非常复杂，运维管理和调用都将变得复杂

分布式最大的缺点就是它存在不可能三角，所谓的不可能的三角指的是：**`CAP`三角**

- `Consistency`一致性：举个例子，假设现在分布式系统中有三个数据库，一个主库两个从库，三个数据库都存放了你的余额并且余额一致，这就是一致性
- ``Availability`可用性：可用性还是用上面一致性的例子，指的是你可以从任意一个数据库中获取到你的余额。
- `Partition Tolerance`分区容错：指的是能够容忍这个系统中有网络延时和抖动。

三条看似时必须要满足的，但是纯分布式系统是无法满足全部的，顶多只能满足两个，**分区容错是一定会被满足的因为现实世界中一定存在网络延迟和抖动**。那就剩一致性和可用性了，当你满足一致性的时候，你就无法满足可用性，比如你现在从一个数据库中更改了余额，那为了保证一致性，你就需要更改其它的数据库，但更改到更改成功的这一时间段中你就无法访问任意一个数据库了，这就违背了可用性。

倘若你满足了可用性，那你修改一个数据库中的余额，你就无法保证其一致性，所以这两者也就是可用性和一致性是无法全部满足的。这就是分布式系统的`CAP`不可能三角的由来。

# `Zookeeper`简介

我们直到了分布式的由来即为什么要有分布式，又知道了分布式是什么，并且还知道分布式本身具有的缺陷即存在`CAP`不可能三角。所以我们需要解决这些问题，于是雅虎开发出了`Zookeeper`这门工具，后来成为`Apache software foundation`的一员。`Zookeeper`就是用来解决不可能`CAP`三角的。

**简单说：`Zookeeper`就是一个运行在分布式系统上的程序，它通过共享存储内容来进行通信。**

`Zookeeper`就是动物园管理员的意思，它可以管理各种“动物“。动物园管理员可以有多个。

- `Zookeeper`是一个中间件，所谓中间件就是可以提供一些方便的第三者，可以提供协调服务
- 作用于分布式系统，发挥其优势，可以为大数据服务
- 支持`Java`，提供`C Java`客户端`API`

`Zookeeper`的特性：

- 一致性：数据一致性，数据按照顺序分批入库

- 原子性：事务要么成功要么失败，不会局部化

- 单一视图：客户端连接集群中的任意一个`Zookeeper`节点其数据都是一致的
- 可靠性：每次对`Zookeeper`的操作状态都会保存在服务端，保证数据安全
- 实时性：客户端可以读取到`Zookeeper`服务端的最新数据

基于这些特性，你就可以让`Zookeeper`来提供分布式锁原型，从而让分布式并发更为简单。

# `Zookeeper`安装

1. 需要安装必要的`JDK`
2. 传输`tar.gz`资源包 ---> `/usr/local/app/..` ---> `tar -zxvf xxx.tar.gz`
3. 配置环境变量
4. 进入`/bin`目录中运行`Zookeeper`服务端即可

# `Zookeeper`配置文件

- `tickTime`：用于计算的时间单元，比如`session`：`N * tickTime`
- `initLimit`：用于集群，允许从节点连接并同步到`master`主节点的初始化连接时间，以`tickTime`的倍数来表示。
- `syncLimit`：用于集群，`master`主节点与从节点之间发送消息，请求和应答的时间长度【心跳机制】，如果超过了这个时间就认为从节点挂了。
- `dataDir`：必须配置，设置数据存储路径
- `dataLogDir`：日志目录，如果不配置就会共用`dataDir`的目录
- `clientPort`：连接服务器的端口，默认为：`2181`，现在只有一个`Zookeeper`日后增多的话这个端口肯定是需要改动的

启动关闭跟重启：

```shell
./zkServer.sh start
./zkServer.sh stop
./zkServer.sh restart
```

# `Zookeeper`基本数据模型

- `Zookeeper`的数据模型是一个树形结构。

  ![](https://img-blog.csdnimg.cn/ba3b97531cdc4fa7b07a8368a64520c8.png)

  我们将上面的树形整体倒转下，`Zookeeper`的树形模型就类似于这样【有点像`Unix/Linux`里的文件结构】：

  ![](https://img-blog.csdnimg.cn/bb18928fd9ed407785711b39e24ba9a7.png)

- `Zookeeper`的数据模型可以理解为`Unix/Linux`的文件目录：`/usr/local/...`

- 我们知道在树中是存在节点这么一种东西的，那`Zookeeper`的基本数据模型就是树形结构当然也不例外，`Zookeeper`的每一个节点都称之为`znode`，它可以由子节点，可以有数据，存储的数据大小不宜过大，几`KB`即可。

  而且每个节点可以分为临时节点和永久节点【做了持久化操作的节点】两种类型，临时节点在客户端端口后就消失【`session`关闭】。

- 每个`Zookeeper`节点都有各自的版本号，每当节点的数据发生变化的时候，该节点的版本号就会进行累加【同乐观锁的原理】，我们可以通过命令行来显示不同节点的信息即查看详情

- 删除/修改过时节点，版本号不匹配的时候则会报错。

- 节点可以设置权限`acl`，可以通过权限来限制用户的访问。

总结下就是：`Zookeeper`存在临时节点和永久节点，客户端断开时临时节点消失，节点可以有子节点并且每个节点都可以存储数据，数据不易过大，几`kb`即可。此外每当节点的数据发生改变时其版本号都会发生变化也就是说节点数据更改采用的是乐观锁机制，除此之外，你还可以给节点设置权限`acl`限制用户的访问。

# `Zookeeper`数据模型的基本操作

- 客户端连接与关闭
- 查看`Zookeeper`节点即`znode`结构

```shell
./zkClient.sh
ls /
ls /zookeeper
ls /zookeeper/config
ls /zookeeper/quota
ctrl + c
```

# `Zookeeper`的作用

1. **保证首脑模式：**我们知道在分布式系统中有主节点和从节点，`Zookeeper`的一个非常大的作用就是当发现主节点挂了之后呢可以让从节点接手工作并且保证这个节点是唯一的，也就是所谓的首脑模式，这样就可以保证我们的集群是高可用的。

2. **统一配置文件管理：**即只需要部署一台服务器就可以把相同的配置文件同步更新到其它所有的服务器，此操作在云计算中使用的特别多，最典型的例子：当我们修改了`redis`的配置，我们就可以不用再手动的一一`copy`，这种操作让`Zookeeper`去完成就可以了，它可以同步更新。

3. **发布与订阅：**该作用类似于消息队列，`Dubbo`等，发布者可以将数据存储在`znode`中，订阅者就可以读取到这些数据

4. **提供分布式锁：**分布式环境中不同进程之间争夺资源，类似于多线程中的锁。最形象的例子就是可以把资源当作是图书馆里的书籍，当某个人借了之后另外一个人他就要等到这个人归还了书籍才可以使用。`Zookeeper`就充当着可以提供分布式锁这项功能的中间件。

   ![](https://img-blog.csdnimg.cn/526d39e28e5841ae8878b51396808e5e.png)

5. **集群管理：集群中保证数据的强一致性。**比如现在主节点中有`/zookeeper/znode`里内有数据`Data-XYZ`，那么从节点也会一并地更新同步，这样我们无论从哪里访问都可以得到最新的数据。这就是集群中保证数据的强一致性。

   